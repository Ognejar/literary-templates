<%*
try {
    // 1. Определяем путь к проекту (аналогично шаблону главы)
    let projectRootPath = '';
    const configFileName = 'Настройки_мира.md';
    const allMarkdownFiles = app.vault.getMarkdownFiles();

    // Начнем с текущей папки, где Templater запускается
    let currentCheckPath = tp.file.folder(true);

    // Поднимаемся вверх по папкам, ища Настройки_мира.md
    while (currentCheckPath && currentCheckPath !== '/') {
        const potentialConfigPath = `${currentCheckPath}/${configFileName}`;
        if (app.vault.getAbstractFileByPath(potentialConfigPath)) {
            projectRootPath = currentCheckPath;
            break;
        }
        const lastSlashIndex = currentCheckPath.lastIndexOf('/');
        currentCheckPath = lastSlashIndex > 0 ? currentCheckPath.substring(0, lastSlashIndex) : '';
    }

    // Если не найдено по текущему пути, попробуем найти из всех файлов
    if (!projectRootPath) {
        const configFiles = allMarkdownFiles.filter(f => f.basename === configFileName);
        if (configFiles.length > 0) {
            projectRootPath = configFiles[0].parent.path;
        } else {
            throw new Error(`Файл "${configFileName}" не найден. Убедитесь, что он существует в корневой папке вашего проекта.`);
        }
    }

    // 2. Загрузка конфига (оставляем как есть)
    const SETTINGS = {
        charactersFolder: "Персонажи",
        configFile: "Настройки_мира.md",
        defaults: {
            characters: {
                races: ["Человек", "Эльф", "Гном", "Дроид"],
                genders: ["Мужской", "Женский", "Другое"],
                statuses: ["Активен", "Мёртв", "Пропал без вести"]
            },
            races: [],
            genders: [],
            statuses: [],
            features: {
                "Эльф": ["Долгожитель", "Отличный стрелок"],
                "Гном": ["Устойчивость к ядам", "Искусный ремесленник"],
                "Дроид": ["Механический организм", "Не требует сна"]
            }
        }
    };

    const loadConfig = async () => {
        const configPath = `${projectRootPath}/${SETTINGS.configFile}`;
        try {
            const file = app.vault.getAbstractFileByPath(configPath);
            if (!file) {
                await app.vault.create(configPath, 
                    "```json\n" + JSON.stringify(SETTINGS.defaults, null, 2) + "\n```"
                );
                return SETTINGS.defaults;
            }
            const content = await app.vault.read(file);
            const configMatch = content.match(/```json\n([\s\S]+?)\n```/);
            const userConfig = configMatch ? JSON.parse(configMatch[1]) : {};

            return {
                ...SETTINGS.defaults,
                ...userConfig,
                characters: {
                    races: userConfig.characters?.races || SETTINGS.defaults.characters.races,
                    genders: userConfig.characters?.genders || SETTINGS.defaults.characters.genders,
                    statuses: userConfig.characters?.statuses || SETTINGS.defaults.characters.statuses
                }
            };
        } catch (e) {
            console.error("Ошибка загрузки конфига:", e);
            return SETTINGS.defaults;
        }
    };

    const worldConfig = await loadConfig();

    // 3. СОЗДАНИЕ ПЕРСОНАЖА
    const name = await tp.system.prompt("Имя персонажа");
    if (!name?.trim()) throw new Error("Имя обязательно!");

    const cleanName = name.trim().replace(/[^а-яА-ЯёЁ\w\s-.]/g, '').replace(/\.md$/i, '');
    const baseFileName = cleanName.replace(/\s+/g, '_');

    // 4. СОХРАНЕНИЕ В ПАПКУ "Персонажи"
    const charactersPath = `${projectRootPath}/${SETTINGS.charactersFolder}`;
    if (!app.vault.getAbstractFileByPath(charactersPath)) {
        await app.vault.createFolder(charactersPath);
    }

    let newFullFileName = baseFileName; // НЕ добавляем .md!
    let targetFilePath = `${charactersPath}/${newFullFileName}`;
    let currentFolder = tp.file.folder(true);
    let currentPathFile = `${currentFolder}/${newFullFileName}`;
    let counter = 2;

    // Проверяем, есть ли файл с таким именем в текущей папке (где создаётся временный файл)
    if (app.vault.getAbstractFileByPath(currentPathFile)) {
        // Предложить нумерацию или другое имя
        new Notice(`В текущей папке уже есть файл с именем: ${currentPathFile}`);
        while (app.vault.getAbstractFileByPath(`${currentFolder}/${baseFileName}_${counter}`)) {
            counter++;
        }
        newFullFileName = `${baseFileName}_${counter}`;
        currentPathFile = `${currentFolder}/${newFullFileName}`;
        targetFilePath = `${charactersPath}/${newFullFileName}`;
        new Notice(`Будет использовано имя: ${newFullFileName}`);
    }

    // Логируем путь поиска
    new Notice(`Проверка файла: ${targetFilePath}`);
    console.log(`[Новый_персонаж] Проверка файла: ${targetFilePath}`);

    // Проверяем, существует ли файл в папке персонажей
    let fileExists = app.vault.getAbstractFileByPath(targetFilePath);
    let fileToOpen = targetFilePath;
    counter = 2;
    if (fileExists) {
        // Спросить пользователя: открыть или создать новый с нумерацией
        const choice = await tp.system.suggester([
            `Открыть существующий (${newFullFileName})`,
            `Создать новый с нумерацией (_2, _3...)`
        ], ["open", "new"]);
        if (choice === "open") {
            new Notice(`Открываю существующий файл: ${targetFilePath}`);
            const file = app.vault.getAbstractFileByPath(targetFilePath);
            if (file) {
                await app.workspace.getLeaf().openFile(file);
            }
            return;
        } else {
            // Ищем свободное имя с суффиксом в папке персонажей
            while (app.vault.getAbstractFileByPath(`${charactersPath}/${baseFileName}_${counter}`)) {
                counter++;
            }
            newFullFileName = `${baseFileName}_${counter}`;
            fileToOpen = `${charactersPath}/${newFullFileName}`;
            new Notice(`Создаю файл: ${fileToOpen}`);
        }
    }

    // Сначала перемещаем временный файл в папку персонажей с уникальным именем
    await tp.file.move(fileToOpen);
    // Затем переименовываем внутри папки (если имя отличается)
    if (tp.file.title !== newFullFileName) {
        await tp.file.rename(newFullFileName);
    }

    // 5. ЗАПОЛНЕНИЕ ДАННЫХ
    const now = tp.date.now("YYYY-MM-DD");
    const status = await tp.system.suggester(worldConfig.characters.statuses, worldConfig.characters.statuses);
    const race = await tp.system.suggester(worldConfig.characters.races, worldConfig.characters.races);
    const gender = await tp.system.suggester(worldConfig.characters.genders, worldConfig.characters.genders);
    const description = await tp.system.prompt("Описание");
    const features = worldConfig.features && worldConfig.features[race] ? worldConfig.features[race] : [];

    let featuresContent = "";
    features.forEach(feature => {
        featuresContent += `- ${feature}\n`;
    });

    // Функция для определения политических тегов
    const getPoliticalTags = (location) => {
        if (!location) return [];
        
        const politicalTags = [];
        
        // Проверяем файлы локаций для определения политической принадлежности
        const locationFiles = app.vault.getMarkdownFiles().filter(f => 
            f.basename.toLowerCase() === location.toLowerCase() ||
            f.basename.toLowerCase().includes(location.toLowerCase())
        );
        
        if (locationFiles.length > 0) {
            const locationFile = locationFiles[0];
            try {
                const locationContent = await app.vault.read(locationFile);
                
                // Ищем ссылки на провинции и государства
                const provinceMatch = locationContent.match(/Провинция.*?\[\[([^\]]+)\]\]/);
                const stateMatch = locationContent.match(/Государство.*?\[\[([^\]]+)\]\]/);
                
                if (provinceMatch) {
                    politicalTags.push(`#${provinceMatch[1].replace(/\s+/g, '_')}`);
                }
                if (stateMatch) {
                    politicalTags.push(`#${stateMatch[1].replace(/\s+/g, '_')}`);
                }
            } catch (e) {
                console.error("Ошибка чтения файла локации:", e);
            }
        }
        
        return politicalTags;
    };

    // Получаем локацию для персонажа
    const location = await tp.system.prompt("Где живет? (введите название города/локации):");
    
    // Получаем политические теги
    const politicalTags = getPoliticalTags(location);
    const allTags = ['people', 'character', ...politicalTags];
-%>
---
created: "<% now %>"
name: "<% cleanName %>"
aliases: ["<% cleanName %>"]
status: "<% status %>"
race: "<% race %>"
gender: "<% gender %>"
tags: [<% allTags.join(', ') %>]
---
# <% cleanName %>

**Статус:** <% status %>  
**Раса:** <% race %>  
**Пол:** <% gender %>  
**Место жительства:** <% 
if (location) {
    // Проверяем, есть ли файл локации
    const locationFiles = app.vault.getMarkdownFiles().filter(f => 
        f.basename.toLowerCase() === location.toLowerCase() ||
        f.basename.toLowerCase().includes(location.toLowerCase())
    );
    
    if (locationFiles.length > 0) {
        // Если найден файл локации, создаем ссылку
        const locationFile = locationFiles[0];
        const relativePath = locationFile.path.replace(projectRootPath + '/', '');
        tR += `[[${relativePath}|${location}]]`;
    } else {
        // Если файл не найден, создаем простую ссылку
        tR += `[[${location}]]`;
    }
} else {
    tR += "Не указано";
}
%>

## Описание
<% description %>

## Особенности
<% featuresContent %>

<% tp.file.cursor() %>

<%* } catch (error) {
    new Notice(`Ошибка: ${error.message}`);
    console.error(error);
} %>