<?php
// build.php — склеивает все js-файлы в один main.js для Obsidian
// Гарантируем работу из директории скрипта
chdir(__DIR__);

$files = [
    'modals.js',           // Сначала вспомогательные модальные окна
    'projectRoot.js',      // Затем утилиты
    'src/settingsService.js', // Сервис настроек и тэговых картинок
    // AI сервисы
    'src/KeyRotationService.js',
    'src/AIProviderService.js',
    'src/LoreAnalyzerService.js',
    // Сервисы для работы с временными слоями
    'src/TimelineService.js',
    'src/TemporalEntityService.js',
    'src/TemporalContextService.js',
    'src/MigrationService.js',
    'src/TemporalAPI.js',
    // Хелперы и UI-слой (должны быть до визардов)
    'helpers/lists.js',
    'helpers/strings.js',
    'ui/adapters/ObsidianSettingAdapter.js',
    'ui/WizardUI.js',
    // Базовые классы для визардов (ПЕРЕД всеми визардами!)
    'creators/HtmlWizardModal.js',
    'creators/EntityWizardBase.js',
    'creators/EntityFactory.js',
    'creators/LoreAnalysisModal.js',
    'creators/EpochManagerModal.js',
    'creators/EpochSelectorModal.js',

    'creators/TaskWizardModal.js',
    // Все визарды из папки creators
    'creators/AlchemyRecipeWizardModal.js',
    'creators/ProjectSelectorModal.js',
    'creators/ChapterSelectorModal.js',
    'creators/WorldSettingsModal.js',
    'creators/PotionWizardModal.js',
    'creators/SpellWizardModal.js',
    'creators/SceneWizardModal.js',
    'creators/VillageWizardModal.js',
    'creators/LocationWizardModal.js',
    'creators/CityWizardModal.js',
    'creators/SocialInstitutionWizardModal.js',
    'creators/DeadZoneWizardModal.js',
    'creators/PortWizardModal.js',
    'creators/ProvinceWizardModal.js',
    'creators/CastleWizardModal.js',
    'creators/MineWizardModal.js',
    'creators/FactoryWizardModal.js',
    'creators/FarmWizardModal.js',
    'creators/StateWizardModal.js',
    'creators/CharacterWizardModal.js',
    'creators/MonsterWizardModal.js',
    'creators/ConflictWizardModal.js',
    'creators/OrganizationWizardModal.js',
    'creators/ReligionWizardModal.js',
    'creators/CultWizardModal.js',
    'creators/TradeRouteWizardModal.js',
    'creators/FactionWizardModal.js',
    'creators/QuestWizardModal.js',
    'creators/EventWizardModal.js',
    'creators/PeopleWizardModal.js',
    'creators/ArtifactWizardModal.js',
    'creators/BaseWizardModal.js',
    'creators/WorkCreationModal.js',
    // Включаем creators файлы - они нужны для standalone функций
    'creators/createWorld.js',
    'creators/createVillage.js',
    'creators/createDeadZone.js',
    'creators/createScene.js',
    'creators/createChapter.js',
    'creators/createCity.js',
    'creators/createLocation.js',
    'creators/createPort.js',
    'creators/createCastle.js',
    'creators/createMine.js',
    'creators/createFactory.js',
    'creators/createFarm.js',
    'creators/createPotion.js',
    'creators/createSpell.js',
    'creators/createPeople.js',
    'creators/createAlchemyRecipe.js',
    'creators/createArtifact.js',
    'creators/createState.js',
    'creators/createProvince.js',
    'creators/createCharacter.js',
    'creators/createMonster.js',
    'creators/createTask.js',
    'creators/createWork.js',
    'creators/createSocialInstitution.js',
    // main.js должен быть последним!
    'main.js',
];

$out = '';
$totalSize = 0;

function echoRed($text) {
    echo "\033[31m$text\033[0m";
}
function echoGreen($text) {
    echo "\033[32m$text\033[0m";
}
// Инициализируем счетчики для require('./src/...')
$countRequireSrc = 0;
$countRequireAssign = 0;
$countRequireSrcAny = 0;
$countConstRequire = 0;
$countRequireSrcAggressive = 0;
$countRequireSrcSimple = 0;
$countRequireSrcPrimitive = 0;
$countSuperAggressive = 0;
$countFinalCleanup = 0;
// Счетчики для require('./main_modules/...')
$countWindowGlobal = 0;
$countRequireMainModules = 0;
$countRequireMainModulesAssign = 0;
$countRequireMainModulesAny = 0;

echo "Размеры исходных файлов:\n";

// Опциональная директория с модульными частями основного плагина
$mainModulesDir = __DIR__ . DIRECTORY_SEPARATOR . 'main_modules';
if (is_dir($mainModulesDir)) {
    $moduleFilesAbs = glob($mainModulesDir . DIRECTORY_SEPARATOR . '*.js');
    if (!empty($moduleFilesAbs)) {
        sort($moduleFilesAbs, SORT_NATURAL);
        $moduleFilesRel = array_map(function ($p) {
            return 'main_modules/' . basename($p);
        }, $moduleFilesAbs);
        $idx = array_search('main.js', $files, true);
        if ($idx === false) {
            $idx = count($files);
        }
        $files = array_merge(array_slice($files, 0, $idx), $moduleFilesRel, array_slice($files, $idx));
        echo "Обнаружены модульные файлы (будут включены перед main.js):\n";
        foreach ($moduleFilesRel as $mf) {
            echo "  + $mf\n";
        }
    }
}
foreach ($files as $file) {
    if (file_exists($file)) {
        $size = filesize($file);
        $totalSize += $size;
        echo str_pad($file, 25) . ': ' . str_pad($size, 8, ' ', STR_PAD_LEFT) . " байт\n";
        $out .= "\n// --- $file ---\n" . file_get_contents($file);
    } else {
        echoRed ("Внимание: файл $file не найден!\n");
    }
}
echo "Суммарный размер всех исходных файлов: $totalSize байт\n";
file_put_contents('main.bundle.js', $out);
echo "Сборка завершена: main.bundle.js\n";

// Простая очистка - удаляем только дублирующиеся импорты obsidian
$main = file_get_contents('main.bundle.js');
// СОХРАНЯЕМ строки глобализации window.* = *; (важно для работы модальных окон)
$main = preg_replace('/^.*window\.[a-zA-Z_$][a-zA-Z0-9_$]*\s*=\s*[a-zA-Z_$][a-zA-Z0-9_$]*;.*\n?/m', '// СОХРАНЕНО: $0', $main, -1, $countWindowGlobal);
echo "Сохранено $countWindowGlobal строк глобализации window.*\n";

// Удаляем ВСЕ строки с импортами obsidian (более агрессивно)
$main = preg_replace('/^.*const \{ .* \} = require\([\'\"]obsidian[\'\"]\);.*\n?/m', '', $main, -1, $count1);

// Удаляем все строки с const { ... } = require('obsidian');
$main = preg_replace('/^.*const \{ .* \} = require\([\'\"]obsidian[\'\"]\);.*\n?/m', '', $main, -1, $count2);

// Удаляем импорты модулей, которые больше не нужны в собранном файле
$main = preg_replace('/^.*const \{ .* \} = require\([\'\"].*\.js[\'\"]\);.*\n?/m', '', $main, -1, $count4);

// Удаляем дублирующиеся функции из main.js, которые уже есть в projectRoot.js
// НЕ удаляем findProjectRoot, getAllProjectRoots, fillTemplate, generateFromTemplate, ensureEntityInfrastructure из main.js
// так как они нужны для работы функций create*

// Удаляем неправильные require импорты из creators файлов, но оставляем createWork
$main = preg_replace('/const \{ (?!createWork).* \} = require\([\'\"].*\.js[\'\"]\);.*\n?/m', '', $main, -1, $count12);
$main = preg_replace('/const \{ (?!createWork).* \} = require\([\'\"].*[\'\"]\);.*\n?/m', '', $main, -1, $count13);

// НЕ удаляем функции create* из main.js - они нужны для работы плагина
// $main = preg_replace('/async function createWorld\(app, plugin, startPath = \'\'\)\s*\{[\s\S]*?\n\}/m', '', $main, -1, $count14);
// $main = preg_replace('/async function createVillage\(app, plugin, startPath = \'\'\)\s*\{[\s\S]*?\n\}/m', '', $main, -1, $count15);
// $main = preg_replace('/async function createDeadZone\(app, plugin, startPath = \'\'\)\s*\{[\s\S]*?\n\}/m', '', $main, -1, $count16);
// $main = preg_replace('/async function createScene\(app, plugin, startPath = \'\'\)\s*\{[\s\S]*?\n\}/m', '', $main, -1, $count17);
// $main = preg_replace('/async function createChapter\(app, plugin, startPath = \'\'\)\s*\{[\s\S]*?\n\}/m', '', $main, -1, $count18);
// $main = preg_replace('/async function createCity\(app, plugin, startPath = \'\'\)\s*\{[\s\S]*?\n\}/m', '', $main, -1, $count19);
// $main = preg_replace('/async function createLocation\(app, plugin, startPath = \'\'\)\s*\{[\s\S]*?\n\}/m', '', $main, -1, $count20);

// Удаляем module.exports из modals.js (не нужен для плагина)
$main = preg_replace('/module\\.exports = \\{ PromptModal, SuggesterModal \\};\\s*\\n/', '', $main, -1, $count11);

// Удаляем module.exports из creators/*.js (делаем функции глобальными)
$main = preg_replace('/module\\.exports = \\{ .* \\};\\s*\\n/', '', $main, -1, $count11a);

// Удаляем дублированные module.exports в конце файла
$main = preg_replace('/module\\.exports = LiteraryTemplatesPlugin;\\s*\\n\\s*module\\.exports = LiteraryTemplatesPlugin;\\s*$/', 'module.exports = LiteraryTemplatesPlugin;', $main, -1, $count9);

// Удаляем ВСЕ вхождения module.exports = LiteraryTemplatesPlugin;
$main = preg_replace('/module\.exports = LiteraryTemplatesPlugin;\s*/', '', $main, -1, $countExports);

// Добавляем правильный экспорт для плагина Obsidian в самый конец файла
$main = rtrim($main) . "\n\nmodule.exports = LiteraryTemplatesPlugin;\n";

// ВОССТАНАВЛИВАЕМ строки глобализации window.* = *; (важно для работы модальных окон)
$main = preg_replace('/\/\/ СОХРАНЕНО: (.*)/m', '$1', $main, -1, $countWindowGlobal);
echo "Восстановлено $countWindowGlobal строк глобализации window.*\n";

// Удаляю добавление глобализации WorkCreationModal и createWork в конец файла (str_replace) - больше не нужно

// Добавляем глобализацию TimelineService как конструктор
$main .= "\n// Глобализация TimelineService для работы createWork\n";
$main .= "window.TimelineService = TimelineService;\n";
$main .= "window.WorkCreationModal = WorkCreationModal;\n";
$main .= "window.CityWizardModal = CityWizardModal;\n";
$main .= "window.MineWizardModal = MineWizardModal;\n";
$main .= "window.VillageWizardModal = VillageWizardModal;\n";
$main .= "window.FarmWizardModal = FarmWizardModal;\n";
$main .= "window.StateWizardModal = StateWizardModal;\n";
$main .= "window.FactoryWizardModal = FactoryWizardModal;\n";
$main .= "window.ProvinceWizardModal = ProvinceWizardModal;\n";
$main .= "window.CastleWizardModal = CastleWizardModal;\n";
$main .= "window.PortWizardModal = PortWizardModal;\n";
$main .= "window.DeadZoneWizardModal = DeadZoneWizardModal;\n";
$main .= "window.LocationWizardModal = LocationWizardModal;\n";
$main .= "window.SocialInstitutionWizardModal = SocialInstitutionWizardModal;\n";
$main .= "window.CharacterWizardModal = CharacterWizardModal;\n";
$main .= "window.PeopleWizardModal = PeopleWizardModal;\n";
$main .= "window.MonsterWizardModal = MonsterWizardModal;\n";
$main .= "window.ArtifactWizardModal = ArtifactWizardModal;\n";
$main .= "window.AlchemyRecipeWizardModal = AlchemyRecipeWizardModal;\n";
$main .= "window.SpellWizardModal = SpellWizardModal;\n";
$main .= "window.PotionWizardModal = PotionWizardModal;\n";
$main .= "window.SceneWizardModal = SceneWizardModal;\n";

// Добавляем один импорт obsidian в начало (включая MarkdownView и requestUrl)
$main = "const { Plugin, Notice, TFile, TFolder, Modal, Setting, MarkdownView, requestUrl } = require('obsidian');\n\n" . $main;

// Удаляем все require('./src/....js')
$main = preg_replace('/^.*require\(["\']\.\/src\/.*["\']\);.*\n?/m', '', $main, -1, $countRequireSrc);
echo "Удалено $countRequireSrc require('./src/...')\n";

// Удаляем все присваивания require('./src/....js') без const/let/var
$main = preg_replace('/^.*[= ]require\([\'\"]\.\/src\/.*[\'\"]\);.*\n?/m', '', $main, -1, $countRequireAssign);
echo "Удалено $countRequireAssign присваиваний require('./src/...')\n";

// Удаляем любые require('./src/...') в любых местах файла (включая KeyRotationService = require(...))
$main = preg_replace('/[a-zA-Z_$][a-zA-Z0-9_$]*\s*=\s*require\([\'"]\.\/src\/.*[\'"]\);?/m', '', $main, -1, $countRequireSrcAny);
echo "Удалено $countRequireSrcAny любых require('./src/...')\n";

// Специально для const/let/var require('./src/...')
$main = preg_replace('/\s*(const|let|var)\s+[a-zA-Z_$][a-zA-Z0-9_$]*\s*=\s*require\([\'"]\.\/src\/.*[\'"]\);?/m', '', $main, -1, $countConstRequire);
echo "Удалено $countConstRequire const/let/var require('./src/...')\n";

// Отладочная информация - показываем что именно ищем
echo "Ищем строки вида: const keyModule = require('./src/KeyRotationService.js');\n";
preg_match_all('/\s*(const|let|var)\s+[a-zA-Z_$][a-zA-Z0-9_$]*\s*=\s*require\([\'"]\.\/src\/.*[\'"]\);?/m', $main, $matches);
echo "Найдено строк для удаления: " . count($matches[0]) . "\n";
if (count($matches[0]) > 0) {
    echo "Примеры найденных строк:\n";
    foreach (array_slice($matches[0], 0, 3) as $match) {
        echo "  " . trim($match) . "\n";
    }
}

// Более агрессивное удаление всех require('./src/...') в любых форматах
$main = preg_replace('/[^;]*require\([\'"]\.\/src\/[^\'"]*[\'"]\)[^;]*;?/m', '', $main, -1, $countRequireSrcAggressive);
echo "Удалено $countRequireSrcAggressive require('./src/...') (агрессивно)\n";

// Самая простая и надежная регулярка - удаляем любую строку, содержащую require('./src/...')
$main = preg_replace('/.*require\([\'"]\.\/src\/.*[\'"]\).*\n?/m', '', $main, -1, $countRequireSrcSimple);
echo "Удалено $countRequireSrcSimple require('./src/...') (простая)\n";

// Самая примитивная регулярка - удаляем любую строку, содержащую './src/'
$main = preg_replace('/.*\.\/src\/.*\n?/m', '', $main, -1, $countRequireSrcPrimitive);
echo "Удалено $countRequireSrcPrimitive строк с './src/' (примитивно)\n";

// СУПЕР АГРЕССИВНОЕ удаление - удаляем ВСЕ строки, содержащие './src/' в любом контексте
$main = preg_replace('/.*\.\/src\/.*\n?/m', '', $main, -1, $countSuperAggressive);
echo "Удалено $countSuperAggressive строк с './src/' (супер агрессивно)\n";

// Финальная проверка - удаляем любые оставшиеся упоминания src
$main = preg_replace('/.*src\/.*\n?/m', '', $main, -1, $countFinalCleanup);
echo "Удалено $countFinalCleanup строк с 'src/' (финальная очистка)\n";

// Удаляем require('./main_modules/...') для итогового файла без require
$main = preg_replace('/^.*require\(["\']\.\/main_modules\/.*["\']\);.*\n?/m', '', $main, -1, $countRequireMainModules);
echo "Удалено $countRequireMainModules require('./main_modules/...')\n";

// Удаляем присваивания require('./main_modules/...')
$main = preg_replace('/^.*[= ]require\([\'\"]\.\/main_modules\/.*[\'\"]\);.*\n?/m', '', $main, -1, $countRequireMainModulesAssign);
echo "Удалено $countRequireMainModulesAssign присваиваний require('./main_modules/...')\n";

// Удаляем любые формы require('./main_modules/...')
$main = preg_replace('/[a-zA-Z_$][a-zA-Z0-9_$]*\s*=\s*require\([\'\"]\.\/main_modules\/.*[\'\"]\);?/m', '', $main, -1, $countRequireMainModulesAny);
echo "Удалено $countRequireMainModulesAny любых require('./main_modules/...')\n";

// Отладочная информация - подсчитываем оставшиеся строки с './src/'
$remainingSrcLines = preg_match_all('/.*\.\/src\/.*\n?/m', $main);
echo "Осталось строк с './src/': $remainingSrcLines\n";

// Если остались строки с './src/' - выводим их для отладки
if ($remainingSrcLines > 0) {
    echoRed("ВНИМАНИЕ: Остались строки с './src/':\n");
    preg_match_all('/.*\.\/src\/.*\n?/m', $main, $matches);
    foreach ($matches[0] as $match) {
        echo "  " . trim($match) . "\n";
    }
}

file_put_contents('main.bundle.js', $main);

$bundleSize = filesize('main.bundle.js');
echo "Размер main.bundle.js: $bundleSize байт\n";
if ($bundleSize > $totalSize) {
    echo "ВНИМАНИЕ: Итоговый файл main.bundle.js больше суммы исходных файлов на " . ($bundleSize - $totalSize) . " байт!\n";
} else {
    echo "main.bundle.js меньше или равен сумме исходных файлов.\n";
}

echo "Удалено $count1 лишних импортов obsidian\n";
echo "Удалено $count2 лишних импортов obsidian (повторно)\n";
echo "Удалено $count4 импортов модулей\n";
echo "Функции findProjectRoot, getAllProjectRoots, fillTemplate, generateFromTemplate, ensureEntityInfrastructure оставлены в main.js\n";
echo "Удалено $count11 module.exports из modals.js\n";
echo "Удалено $count11a module.exports из creators\n";
echo "Удалено $count12 неправильных require импортов из creators\n";
echo "Удалено $count13 неправильных require импортов (общий)\n";
echo "Функции create* сохранены в main.js (не удаляем)\n";
echo "Удалено $count9 дублированных module.exports\n";
echo "Проверен экспорт для плагина\n";

// --- АНАЛИЗ ДУБЛИКАТОВ ---
function analyzeDuplicates($filename)
{
    $code = file_get_contents($filename);
    $lines = explode("\n", $code);
    $signatures = [];
    foreach ($lines as $line) {
        // Ищем function, class, const/let/var <name> = (function|async function|class)
        if (preg_match('/^\s*function\s+([a-zA-Z0-9_]+)/', $line, $m)) {
            $signatures[] = 'function ' . $m[1];
        } elseif (preg_match('/^\s*class\s+([a-zA-Z0-9_]+)/', $line, $m)) {
            $signatures[] = 'class ' . $m[1];
        } elseif (preg_match('/^\s*(const|let|var)\s+([a-zA-Z0-9_]+)\s*=\s*(async\s+)?function/', $line, $m)) {
            $signatures[] = $m[1] . ' ' . $m[2] . ' = function';
        } elseif (preg_match('/^\s*(const|let|var)\s+([a-zA-Z0-9_]+)\s*=\s*class/', $line, $m)) {
            $signatures[] = $m[1] . ' ' . $m[2] . ' = class';
        }
    }
    $counts = array_count_values($signatures);
    arsort($counts);
    $duplicates = array_filter($counts, function ($v) {
        return $v > 1;
    });
    if (count($duplicates) > 0) {
        echo "\nТоп-10 дублирующихся сигнатур (function/class):\n";
        $i = 0;
        foreach ($duplicates as $sig => $cnt) {
            echo str_pad($sig, 40) . ": " . $cnt . "\n";
            $i++;
            if ($i >= 10) break;
        }
    } else {
        echo "\nДублирующихся function/class не найдено.\n";
    }
}
analyzeDuplicates('main.bundle.js');

// Копируем результат в папку плагина Obsidian
$target = 'C:/Obsidian_data_C/.obsidian/plugins/literary-templates/main.js';
if (copy('main.bundle.js', $target)) {
    echo "main.bundle.js скопирован в $target\n";
} else {
    echoRed ("Ошибка копирования main.bundle.js в $target\n");
}

// --- КОПИРОВАНИЕ ШАБЛОНОВ ---
function copyDir($src, $dst)
{
    if (!is_dir($src)) return false;
    if (!is_dir($dst)) mkdir($dst, 0777, true);
    $dir = opendir($src);
    while (false !== ($file = readdir($dir))) {
        if (($file != '.') && ($file != '..')) {
            if (is_dir($src . '/' . $file)) {
                copyDir($src . '/' . $file, $dst . '/' . $file);
            } else {
                copy($src . '/' . $file, $dst . '/' . $file);
            }
        }
    }
    closedir($dir);
    return true;
}

$srcTemplates = __DIR__ . '/templates';
$dstTemplates = 'C:/Obsidian_data_C/.obsidian/plugins/literary-templates/templates';
if (copyDir($srcTemplates, $dstTemplates)) {
    echo "Шаблоны скопированы в $dstTemplates\n";
} else {
    echoRed ("Ошибка копирования шаблонов в $dstTemplates\n");
}

// Копируем секции шаблонов
$srcSections = __DIR__ . '/templates/sections';
$dstSections = 'C:/Obsidian_data_C/.obsidian/plugins/literary-templates/templates/sections';

// Диагностика исходной папки
if (!is_dir($srcSections)) {
    echoRed ("Исходная папка секций не найдена: $srcSections\n");
} else {
    echo "Исходная папка секций найдена: $srcSections\n";
    // Автоматически создаём целевую папку, если её нет
    if (!is_dir($dstSections)) {
        if (mkdir($dstSections, 0777, true)) {
            echo "Целевая папка секций создана: $dstSections\n";
        } else {
            echoRed ("Не удалось создать целевую папку секций: $dstSections\n");
        }
    }
}
if (copyDir($srcSections, $dstSections)) {
    echo "Секции шаблонов скопированы в $dstSections\n";
} else {
    echoRed("Ошибка копирования секций шаблонов в $dstSections\n");
}

// Копируем пиктограммы
$srcicons = __DIR__ . '/templates/icons';
$dsticons = 'C:/Obsidian_data_C/.obsidian/plugins/literary-templates/templates/icons';

// Диагностика исходной папки
if (!is_dir($srcicons)) {
    echoRed ("Исходная папка пиктограмм не найдена: $srcicons\n");
} else {
    echo "Исходная папка пиктограмм найдена: $srcicons\n";
    // Автоматически создаём целевую папку, если её нет
    if (!is_dir($dsticons)) {
        if (mkdir($dsticons, 0777, true)) {
            echo "Целевая папка пиктограмм создана: $dsticons\n";
        } else {
            echoRed ("Не удалось создать целевую папку пиктограмм: $dsticons\n");
        }
    }
}
if (copyDir($srcicons, $dsticons)) {
    echo "Пиктограммы скопированы в $dsticons\n";
} else {
    echoRed ("Ошибка копирования пиктограмм в $dsticons\n");
}

// Копируем скрипты
$srcscripts = __DIR__ . '/templates/scripts';
$dstscripts = 'C:/Obsidian_data_C/.obsidian/plugins/literary-templates/scripts';

// Диагностика исходной папки
if (!is_dir($srcscripts)) {
    echoRed ("Исходная папка скриптов не найдена: $srcscripts\n");
} else {
    echo "Исходная папка скриптов найдена: $srcscripts\n";
    // Автоматически создаём целевую папку, если её нет
    if (!is_dir($dstscripts)) {
        if (mkdir($dstscripts, 0777, true)) {
            echo "Целевая папка скриптов создана: $dstscripts\n";
        } else {
            echoRed ("Не удалось создать целевую папку скриптов: $dstscripts\n");
        }
    }
}
if (copyDir($srcscripts, $dstscripts)) {
    echo "Скрипты скопированы в $dstscripts\n";
} else {
    echoRed ("Ошибка копирования скриптов в $dstscripts\n");
}


// Копируем теговые картинки
$srcTagImages = __DIR__ . '/templates/Теговые_картинки';
$dstTagImages = 'C:/Obsidian_data_C/.obsidian/plugins/literary-templates/templates/Теговые_картинки';

// Диагностика исходной папки
if (!is_dir($srcTagImages)) {
    echoRed ("Исходная папка теговых картинок не найдена: $srcTagImages\n");
} else {
    echo "Исходная папка теговых картинок найдена: $srcTagImages\n";
    // Автоматически создаём целевую папку, если её нет
    if (!is_dir($dstTagImages)) {
        if (mkdir($dstTagImages, 0777, true)) {
            echo "Целевая папка теговых картинок создана: $dstTagImages\n";
        } else {
            echoRed ("Не удалось создать целевую папку теговых картинок: $dstTagImages\n");
        }
    }
}
if (copyDir($srcTagImages, $dstTagImages)) {
    echo "Теговые картинки скопированы в $dstTagImages\n";
} else {
    echoRed ("Ошибка копирования теговых картинок в $dstTagImages\n");
}
